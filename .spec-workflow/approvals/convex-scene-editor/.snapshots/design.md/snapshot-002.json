{
  "id": "snapshot_1769982248025_edo5okuu9",
  "approvalId": "approval_1769973484981_4svlc86vw",
  "approvalTitle": "Design Document - Convex Scene Editor",
  "version": 2,
  "timestamp": "2026-02-01T21:44:08.025Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Convex Scene Editor\r\n\r\n## Overview\r\n\r\nThe Convex Scene Editor is a C++ application built on a custom game engine that demonstrates computational geometry concepts through interactive 2D convex polygon manipulation and raycast performance analysis. The system architecture follows a modular design with clear separation between scene management, rendering, spatial optimization, and user interaction layers.\r\n\r\nThe design leverages existing engine capabilities (math utilities, rendering primitives, input handling) while implementing custom convex geometry algorithms and spatial partitioning structures (BVH and QuadTree) for raycast optimization.\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards\r\n\r\nThis design follows C++ best practices and game engine architecture patterns:\r\n- **SOLID Principles**: Single responsibility for each class, open/closed for spatial structures\r\n- **RAII**: Proper resource management for dynamically allocated convex objects\r\n- **Const Correctness**: Render methods are const, mutators are non-const\r\n- **Value Semantics**: Math types (Vec2, AABB2) use value semantics\r\n- **Pointer Semantics**: Game objects use pointer semantics with manual memory management\r\n\r\n### Project Structure\r\n\r\nThe implementation follows the existing engine project structure:\r\n```\r\nCode/Game/\r\n├── Framework/\r\n│   ├── App.cpp/hpp          # Application lifecycle (existing)\r\n│   ├── GameCommon.cpp/hpp   # Global utilities (existing)\r\n│   └── Main_Windows.cpp     # Entry point (existing)\r\n└── Gameplay/\r\n    ├── Game.cpp/hpp          # Main game logic (extend)\r\n    ├── Convex.cpp/hpp        # NEW: Convex shape class\r\n    ├── BVH.cpp/hpp           # NEW: BVH spatial partitioning\r\n    └── QuadTree.cpp/hpp      # NEW: QuadTree spatial partitioning\r\n```\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Engine Components to Leverage\r\n\r\n#### Math Library (`Engine/Math/`)\r\n- **Vec2**: 2D vector operations, polar coordinate generation, rotation\r\n- **AABB2**: Bounding box representation for spatial partitioning\r\n- **Disc2**: Bounding disc for broad-phase culling\r\n- **Plane2**: Half-space representation for convex hulls\r\n- **ConvexHull2**: Plane-based convex representation (existing in reference Engine)\r\n- **ConvexPoly2**: Vertex-based convex representation (existing in reference Engine)\r\n- **RaycastResult2D**: Raycast result structure\r\n- **RandomNumberGenerator**: Deterministic random number generation\r\n- **MathUtils**: Dot product, cross product, angle utilities, point-in-polygon tests\r\n\r\n#### Rendering System (`Engine/Renderer/`)\r\n- **Vertex_PCU**: Position-Color-UV vertex structure\r\n- **VertexUtils**: Primitive generation functions\r\n  - `AddVertsForConvexPoly2D()`: Fill convex polygon\r\n  - `AddVertsForLineSegment2D()`: Draw edges\r\n  - `AddVertsForArrow2D()`: Draw surface normals\r\n  - `AddVertsForDisc2D()`: Draw bounding discs\r\n- **Renderer**: Drawing API with blend modes, state management\r\n- **Camera**: Orthographic 2D camera\r\n- **BitmapFont**: Text rendering for UI metrics\r\n\r\n#### Core Systems (`Engine/Core/`)\r\n- **Clock**: Time management, delta time, FPS calculation\r\n- **InputSystem**: Keyboard and mouse input\r\n- **EventSystem**: Event subscription/firing\r\n- **StringUtils**: `Stringf()` for formatted text\r\n\r\n#### Raycast Utilities (`Engine/Math/RaycastUtils.hpp`)\r\n- **RaycastVsDisc2D()**: Ray-disc intersection (for broad-phase culling)\r\n- **RaycastVsAABB2D()**: Ray-AABB intersection (for spatial structure traversal)\r\n- **RaycastVsConvexHull2D()**: Ray-convex intersection (core algorithm)\r\n\r\n### Integration Points\r\n\r\n- **Game Class**: Extend existing `Game` class to add convex scene management\r\n- **Rendering Pipeline**: Integrate with existing `Render()` method using `VertexList_PCU`\r\n- **Input Handling**: Use existing `InputSystem` for keyboard/mouse controls\r\n- **Debug Rendering**: Use existing `DebugRenderSystem` for debug visualization\r\n\r\n## Architecture\r\n\r\n### System Architecture\r\n\r\n```mermaid\r\ngraph TD\r\n    A[App] --> B[Game]\r\n    B --> C[Convex2 Array]\r\n    B --> D[AABB2Tree]\r\n    B --> E[SymmetricQuadTree]\r\n    B --> F[Raycast2DVisualizer]\r\n\r\n    C --> G[ConvexHull2]\r\n    C --> H[ConvexPoly2]\r\n    C --> I[Bounding Volumes]\r\n\r\n    D --> C\r\n    E --> C\r\n\r\n    B --> J[Renderer]\r\n    B --> K[InputSystem]\r\n    B --> L[Clock]\r\n\r\n    style B fill:#e1f5fe\r\n    style C fill:#fff3e0\r\n    style D fill:#f3e5f5\r\n    style E fill:#f3e5f5\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n- **Single File Responsibility**:\r\n  - `Convex.cpp/hpp`: Convex shape representation and operations only\r\n  - `BVH.cpp/hpp`: BVH spatial partitioning only\r\n  - `QuadTree.cpp/hpp`: QuadTree spatial partitioning only\r\n  - `Game.cpp/hpp`: Scene orchestration and user interaction only\r\n\r\n- **Component Isolation**:\r\n  - Spatial structures are independent of each other\r\n  - Convex shapes don't know about spatial structures\r\n  - Rendering is separated from game logic\r\n\r\n- **Service Layer Separation**:\r\n  - Data: `Convex2`, `AABB2TreeNode`, `SymmetricQuadTreeNode`\r\n  - Logic: Raycast algorithms, spatial structure queries\r\n  - Presentation: Rendering methods in `Game`\r\n\r\n- **Utility Modularity**:\r\n  - Random convex generation is a standalone function\r\n  - Vertex generation helpers are separate methods\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: Convex2 Class\r\n\r\n**Purpose:** Represents a 2D convex polygon with dual representation (hull + poly) and bounding volumes for optimization.\r\n\r\n**File:** `Code/Game/Convex.hpp`, `Code/Game/Convex.cpp`\r\n\r\n**Interfaces:**\r\n```cpp\r\nclass Convex2 {\r\npublic:\r\n    // Constructors\r\n    Convex2();\r\n    Convex2(ConvexPoly2 const& convexPoly2);\r\n    Convex2(ConvexHull2 const& convexHull2);\r\n    Convex2(std::vector<Vec2> const& vertices);  // From vertex list\r\n\r\n    // Queries\r\n    bool IsPointInside(Vec2 const& point) const;\r\n    bool RayCastVsConvex2D(RayCastResult2D& out_result,\r\n                           Vec2 const& startPos,\r\n                           Vec2 const& forwardNormal,\r\n                           float maxDist,\r\n                           bool discRejection = true,\r\n                           bool boxRejection = false) const;\r\n\r\n    // Transforms\r\n    void Translate(Vec2 const& offset);\r\n    void Rotate(float degrees, Vec2 const& refPoint = Vec2::ZERO);\r\n    void Scale(float scaleFactor, Vec2 const& refPoint = Vec2::ZERO);\r\n    void RebuildBoundingBox();\r\n\r\n    // Data members\r\n    ConvexHull2 m_convexHull;           // Plane representation\r\n    ConvexPoly2 m_convexPoly;           // Vertex representation\r\n    AABB2 m_boundingAABB;               // Bounding box\r\n    Vec2 m_boundingDiscCenter;          // Bounding disc center\r\n    float m_boundingRadius;             // Bounding disc radius\r\n    float m_scale = 1.f;                // Current scale\r\n    bool m_symmetricQuadTreeFlag = false; // For deduplication in QuadTree\r\n};\r\n```\r\n\r\n**Dependencies:**\r\n- `Engine/Math/ConvexHull2.hpp`\r\n- `Engine/Math/ConvexPoly2.hpp`\r\n- `Engine/Math/AABB2.hpp`\r\n- `Engine/Math/Vec2.hpp`\r\n- `Engine/Math/RaycastUtils.hpp`\r\n\r\n**Reuses:**\r\n- `ConvexHull2` for plane-based representation\r\n- `ConvexPoly2` for vertex-based representation\r\n- `RaycastVsConvexHull2D()` for ray intersection\r\n- `RaycastVsDisc2D()` for broad-phase culling\r\n- `RaycastVsAABB2D()` for box rejection\r\n- `IsPointInsideConvexHull2D()` for point-in-polygon test\r\n\r\n### Component 2: AABB2Tree Class (BVH)\r\n\r\n**Purpose:** Binary space partitioning tree for accelerating raycast queries using axis-aligned bounding boxes.\r\n\r\n**File:** `Code/Game/BVH.hpp`, `Code/Game/BVH.cpp`\r\n\r\n**Interfaces:**\r\n```cpp\r\nstruct AABB2TreeNode {\r\n    AABB2 m_bounds;\r\n    std::vector<Convex2*> m_containingConvex;\r\n};\r\n\r\nclass AABB2Tree {\r\npublic:\r\n    void BuildTree(std::vector<Convex2*> const& convexArray,\r\n                   int numOfRecursive,\r\n                   AABB2 const& totalBounds);\r\n\r\n    void SolveRayResult(Vec2 const& startPos,\r\n                        Vec2 const& forwardVec,\r\n                        float maxDist,\r\n                        std::vector<Convex2*>& out_latentRes);\r\n\r\n    std::vector<AABB2TreeNode> m_nodes;\r\n    int m_startOfLastLevel = 0;  // Index where leaf nodes begin\r\n\r\nprotected:\r\n    int GetParentIndex(int index);\r\n};\r\n```\r\n\r\n**Algorithm:**\r\n- **Tree Structure**: Binary tree with alternating vertical/horizontal splits\r\n- **Partitioning**: Uses convex bounding disc center for assignment\r\n- **Depth**: `log2(numObjects) - 3` (minimum 3 levels)\r\n- **Traversal**: Depth-first with AABB ray intersection tests\r\n\r\n**Dependencies:**\r\n- `Engine/Math/AABB2.hpp`\r\n- `Engine/Math/RaycastUtils.hpp` (for `RaycastVsAABB2D()`)\r\n- `Game/Convex.hpp`\r\n\r\n**Reuses:**\r\n- `AABB2` for node bounds\r\n- `RaycastVsAABB2D()` for ray-box intersection tests\r\n- `Convex2::m_boundingDiscCenter` for partitioning\r\n\r\n### Component 3: SymmetricQuadTree Class\r\n\r\n**Purpose:** Quad tree spatial partitioning for accelerating raycast queries using uniform grid subdivision.\r\n\r\n**File:** `Code/Game/QuadTree.hpp`, `Code/Game/QuadTree.cpp`\r\n\r\n**Interfaces:**\r\n```cpp\r\nstruct SymmetricQuadTreeNode {\r\n    AABB2 m_bounds;\r\n    std::vector<Convex2*> m_containingConvex;\r\n};\r\n\r\nclass SymmetricQuadTree {\r\npublic:\r\n    void BuildTree(std::vector<Convex2*> const& convexArray,\r\n                   int numOfRecursive,\r\n                   AABB2 const& totalBounds);\r\n\r\n    void SolveRayResult(Vec2 const& startPos,\r\n                        Vec2 const& forwardVec,\r\n                        float maxDist,\r\n                        std::vector<Convex2*> const& convexArray,\r\n                        std::vector<Convex2*>& out_latentRes);\r\n\r\nprotected:\r\n    int GetFirstLBChild(int index);   // Left-Bottom\r\n    int GetSecondRBChild(int index);  // Right-Bottom\r\n    int GetThirdLTChild(int index);   // Left-Top\r\n    int GetForthRTChild(int index);   // Right-Top\r\n    int GetParentIndex(int index);\r\n\r\n    std::vector<SymmetricQuadTreeNode> m_nodes;\r\n};\r\n```\r\n\r\n**Algorithm:**\r\n- **Tree Structure**: Quad tree with 4 children per node\r\n- **Partitioning**: Divides space into 4 equal quadrants\r\n- **Depth**: Fixed at 4 levels (hardcoded)\r\n- **Assignment**: Leaf nodes check AABB overlap with convex shapes\r\n- **Deduplication**: Uses `Convex2::m_symmetricQuadTreeFlag` to avoid duplicate checks\r\n\r\n**Dependencies:**\r\n- `Engine/Math/AABB2.hpp`\r\n- `Engine/Math/MathUtils.hpp` (for `DoAABB2sOverlap2D()`)\r\n- `Engine/Math/RaycastUtils.hpp`\r\n- `Game/Convex.hpp`\r\n\r\n**Reuses:**\r\n- `AABB2` for node bounds\r\n- `DoAABB2sOverlap2D()` for overlap tests\r\n- `RaycastVsAABB2D()` for ray-box intersection tests\r\n\r\n### Component 4: Game Class (Extended)\r\n\r\n**Purpose:** Orchestrates scene management, user interaction, rendering, and performance measurement.\r\n\r\n**File:** `Code/Game/Gameplay/Game.hpp`, `Code/Game/Gameplay/Game.cpp`\r\n\r\n**New Members:**\r\n```cpp\r\nclass Game {\r\n    // Scene data\r\n    std::vector<Convex2*> m_convexArray;\r\n    int m_numOfRandomRays = 1024;\r\n\r\n    // Interaction\r\n    Convex2* m_hoveringConvex = nullptr;\r\n    Vec2 m_cursorPrevPos;\r\n    bool m_isDragging = false;\r\n\r\n    // Rendering modes\r\n    bool m_drawEdgesMode = false;      // F2: Toggle draw mode\r\n    bool m_debugDrawMode = false;      // F1: Show bounding discs\r\n    bool m_debugDrawBVHMode = false;   // F4: Show spatial structure\r\n\r\n    // Performance metrics\r\n    float m_lastRayTestNormalTime = 0.f;\r\n    float m_lastRayTestDiscRejectionTime = 0.f;\r\n    float m_lastRayTestAABBRejectionTime = 0.f;\r\n    float m_lastRayTestSymmetricTreeTime = 0.f;\r\n    float m_lastRayTestAABBTreeTime = 0.f;\r\n    float m_avgDist = 0.f;\r\n\r\n    // Visible raycast\r\n    Vec2 m_rayStart;\r\n    Vec2 m_rayEnd;\r\n\r\n    // Spatial structures\r\n    SymmetricQuadTree m_symQuadTree;\r\n    AABB2Tree m_AABB2Tree;\r\n\r\n    // Random generation\r\n    unsigned int m_seed = 1;\r\n    RandomNumberGenerator* m_randNumGen;\r\n\r\n    // Methods\r\n    Convex2* GenerateRandomConvex(int index) const;\r\n    void RebuildAllTrees();\r\n    void TestRays();\r\n    void HandleKeys();\r\n    void AddVertsForConvexPolyEdges(std::vector<Vertex_PCU>& verts,\r\n                                     ConvexPoly2 const& convexPoly2,\r\n                                     float thickness,\r\n                                     Rgba8 const& color) const;\r\n};\r\n```\r\n\r\n**Dependencies:**\r\n- `Game/Convex.hpp`\r\n- `Game/BVH.hpp`\r\n- `Game/QuadTree.hpp`\r\n- `Engine/Math/RandomNumberGenerator.hpp`\r\n- `Engine/Core/Clock.hpp`\r\n- `Engine/Input/InputSystem.hpp`\r\n- `Engine/Renderer/Renderer.hpp`\r\n\r\n**Reuses:**\r\n- Existing `Game` class structure\r\n- `RandomNumberGenerator` for deterministic generation\r\n- `Clock` for FPS and timing\r\n- `InputSystem` for controls\r\n- `Renderer` for drawing\r\n\r\n## Data Models\r\n\r\n### Convex2 Data Model\r\n```cpp\r\nstruct Convex2 {\r\n    // Dual representation\r\n    ConvexHull2 m_convexHull;           // Plane equations (for raycasting)\r\n    ConvexPoly2 m_convexPoly;           // Vertices (for rendering)\r\n\r\n    // Bounding volumes (for optimization)\r\n    AABB2 m_boundingAABB;               // Axis-aligned bounding box\r\n    Vec2 m_boundingDiscCenter;          // Bounding disc center\r\n    float m_boundingRadius;             // Bounding disc radius\r\n\r\n    // Transform state\r\n    float m_scale;                      // Current scale factor\r\n\r\n    // Flags\r\n    bool m_symmetricQuadTreeFlag;       // For QuadTree deduplication\r\n};\r\n```\r\n\r\n### AABB2TreeNode Data Model\r\n```cpp\r\nstruct AABB2TreeNode {\r\n    AABB2 m_bounds;                     // Node bounding box\r\n    std::vector<Convex2*> m_containingConvex;  // Convex shapes in this node\r\n};\r\n```\r\n\r\n### SymmetricQuadTreeNode Data Model\r\n```cpp\r\nstruct SymmetricQuadTreeNode {\r\n    AABB2 m_bounds;                     // Node bounding box\r\n    std::vector<Convex2*> m_containingConvex;  // Convex shapes in this node\r\n};\r\n```\r\n\r\n### RaycastResult2D Data Model (Existing)\r\n```cpp\r\nstruct RaycastResult2D {\r\n    bool m_didImpact;                   // Hit flag\r\n    Vec2 m_impactPosition;              // Impact point\r\n    Vec2 m_impactNormal;                // Surface normal\r\n    float m_impactLength;               // Distance to impact\r\n\r\n    // Optional: original ray info\r\n    Vec2 m_rayStartPosition;\r\n    Vec2 m_rayForwardNormal;\r\n    float m_rayMaxLength;\r\n};\r\n```\r\n\r\n## Key Algorithms\r\n\r\n### Algorithm 1: Random Convex Generation\r\n\r\n**Purpose:** Generate deterministic random convex polygons using noise functions.\r\n\r\n**Implementation:**\r\n```cpp\r\nConvex2* Game::GenerateRandomConvex(int index) const {\r\n    // 1. Random vertex count (3-8 vertices, bias against 7-8)\r\n    int numOfVerts = (Get1dNoiseUint(index, m_seed) & 0x7fffffff) % 6 + 3;\r\n    if (numOfVerts >= 7) {\r\n        numOfVerts = (Get1dNoiseUint(index, m_seed + 1) & 0x7fffffff) % 6 + 3;\r\n    }\r\n\r\n    // 2. Generate angles (evenly distributed + random offset)\r\n    std::vector<float> angles;\r\n    for (int i = 0; i < numOfVerts; ++i) {\r\n        float baseAngle = i * 360.f / numOfVerts;\r\n        float offset = Get2dNoiseZeroToOne(index, i, m_seed + 5) * 360.f / numOfVerts;\r\n        angles.push_back(baseAngle + offset);\r\n    }\r\n    // Note: Angles are already in sorted order (CCW)\r\n\r\n    // 3. Random radius and center\r\n    float radius = Get1dNoiseZeroToOne(index, m_seed + 2) * 12.f + 4.f;\r\n    Vec2 centerPos = Vec2(\r\n        Get1dNoiseZeroToOne(index, m_seed + 3) * (WORLD_SIZE_X - 2.f * radius) + radius,\r\n        Get1dNoiseZeroToOne(index, m_seed + 4) * (WORLD_SIZE_Y - 2.f * radius) + radius\r\n    );\r\n\r\n    // 4. Generate vertices in polar coordinates\r\n    std::vector<Vec2> vertices;\r\n    for (float angle : angles) {\r\n        vertices.push_back(Vec2::MakeFromPolarDegrees(angle, radius) + centerPos);\r\n    }\r\n\r\n    // 5. Create convex and set bounding volumes\r\n    Convex2* convex = new Convex2(vertices);\r\n    convex->m_boundingDiscCenter = centerPos;\r\n    convex->m_boundingRadius = radius;\r\n    convex->RebuildBoundingBox();\r\n    return convex;\r\n}\r\n```\r\n\r\n**Key Points:**\r\n- Uses noise functions for deterministic randomness (reproducible with seed)\r\n- Angles are evenly distributed with random offset (ensures convexity)\r\n- No sorting needed - angles already in CCW order\r\n- Radius: 4-16 units, ensures shapes fit in world bounds\r\n\r\n### Algorithm 2: Ray-Convex Intersection\r\n\r\n**Purpose:** Determine if a ray intersects a convex polygon using plane equations.\r\n\r\n**Implementation:**\r\n```cpp\r\nbool Convex2::RayCastVsConvex2D(RayCastResult2D& out_result,\r\n                                 Vec2 const& startPos,\r\n                                 Vec2 const& forwardNormal,\r\n                                 float maxDist,\r\n                                 bool discRejection,\r\n                                 bool boxRejection) const {\r\n    // Optional: Broad-phase disc rejection\r\n    if (discRejection) {\r\n        RayCastResult2D discResult;\r\n        if (!RayCastVsDisc2D(discResult, startPos, forwardNormal, maxDist,\r\n                             m_boundingDiscCenter, m_boundingRadius)) {\r\n            out_result.m_didImpact = false;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Optional: Broad-phase AABB rejection\r\n    if (boxRejection) {\r\n        if (!RayCastVsAABB2DResultOnly(startPos, forwardNormal, maxDist, m_boundingAABB)) {\r\n            out_result.m_didImpact = false;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Narrow-phase: Ray-convex hull intersection\r\n    return RayCastVsConvexHull2D(out_result, startPos, forwardNormal, maxDist, m_convexHull);\r\n}\r\n```\r\n\r\n**RaycastVsConvexHull2D Algorithm (Engine utility):**\r\n```\r\n1. Initialize tEnter = 0, tExit = maxDist\r\n2. For each plane in convex hull:\r\n   a. Calculate vd = dot(rayForward, planeNormal)\r\n   b. Calculate v0 = planeAltitude(rayStart)\r\n   c. If ray parallel to plane (|vd| < EPSILON):\r\n      - If outside (v0 > 0): return MISS\r\n      - Continue to next plane\r\n   d. Calculate t = -v0 / vd\r\n   e. If entering (vd < 0):\r\n      - Update tEnter = max(tEnter, t)\r\n      - Store enterNormal = planeNormal\r\n   f. If exiting (vd > 0):\r\n      - Update tExit = min(tExit, t)\r\n   g. If tEnter > tExit: return MISS\r\n3. If tEnter < 0 or tEnter > maxDist: return MISS\r\n4. Return HIT with impactPos = rayStart + rayForward * tEnter, impactNormal = enterNormal\r\n```\r\n\r\n### Algorithm 3: Batch Raycast Performance Testing\r\n\r\n**Purpose:** Measure raycast performance across different optimization modes.\r\n\r\n**Implementation:**\r\n```cpp\r\nvoid Game::TestRays() {\r\n    // 1. Generate random rays\r\n    std::vector<Vec2> rayStartPos, rayForwardNormal;\r\n    std::vector<float> rayMaxDist;\r\n    for (int i = 0; i < m_numOfRandomRays; ++i) {\r\n        Vec2 start = GetRandomPointInAABB2D(worldBounds);\r\n        Vec2 end = GetRandomPointInAABB2D(worldBounds);\r\n        Vec2 disp = end - start;\r\n        float dist = disp.GetLength();\r\n        rayStartPos.push_back(start);\r\n        rayMaxDist.push_back(dist);\r\n        rayForwardNormal.push_back(disp / dist);\r\n    }\r\n\r\n    // 2. Test NO optimization (brute force)\r\n    double startTime = GetCurrentTimeSeconds();\r\n    for (int j = 0; j < m_numOfRandomRays; ++j) {\r\n        float minDist = FLT_MAX;\r\n        for (int i = 0; i < m_convexArray.size(); ++i) {\r\n            RayCastResult2D result;\r\n            if (m_convexArray[i]->RayCastVsConvex2D(result, rayStartPos[j],\r\n                                                     rayForwardNormal[j],\r\n                                                     rayMaxDist[j], false, false)) {\r\n                minDist = min(minDist, result.m_impactDist);\r\n            }\r\n        }\r\n    }\r\n    m_lastRayTestNormalTime = (GetCurrentTimeSeconds() - startTime) * 1000.0;\r\n\r\n    // 3. Test DISC rejection\r\n    // ... (same loop with discRejection=true)\r\n\r\n    // 4. Test AABB rejection\r\n    // ... (same loop with boxRejection=true)\r\n\r\n    // 5. Test Symmetric Quad Tree\r\n    for (int j = 0; j < m_numOfRandomRays; ++j) {\r\n        std::vector<Convex2*> candidates;\r\n        m_symQuadTree.SolveRayResult(rayStartPos[j], rayForwardNormal[j],\r\n                                      rayMaxDist[j], m_convexArray, candidates);\r\n        // Test only candidate convexes\r\n        for (auto convex : candidates) {\r\n            // ... raycast test\r\n        }\r\n    }\r\n\r\n    // 6. Test AABB2 BVH Tree\r\n    // ... (similar to quad tree)\r\n}\r\n```\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n1. **Scenario: Invalid Convex Generation**\r\n   - **Handling:** Validate vertex count (3-8), ensure CCW winding\r\n   - **User Impact:** None (internal validation)\r\n\r\n2. **Scenario: Spatial Structure Build Failure**\r\n   - **Handling:** Gracefully degrade to brute force raycasting\r\n   - **User Impact:** Performance degradation, no crash\r\n\r\n3. **Scenario: Numerical Instability in Raycast**\r\n   - **Handling:** Use EPSILON for floating-point comparisons\r\n   - **User Impact:** Rare edge cases handled correctly\r\n\r\n4. **Scenario: Memory Allocation Failure**\r\n   - **Handling:** Check for nullptr after new, use RAII patterns\r\n   - **User Impact:** Graceful degradation or controlled shutdown\r\n\r\n5. **Scenario: Invalid User Input**\r\n   - **Handling:** Clamp values (object count ≥ 1, raycast count ≥ 1)\r\n   - **User Impact:** Prevents invalid states\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**Key Components to Test:**\r\n- `Convex2::IsPointInside()` - Test with points inside, outside, on edge\r\n- `Convex2::RayCastVsConvex2D()` - Test hits, misses, grazing rays, parallel rays\r\n- `AABB2Tree::BuildTree()` - Verify tree structure, node bounds\r\n- `SymmetricQuadTree::BuildTree()` - Verify tree structure, node bounds\r\n- `GenerateRandomConvex()` - Verify vertex count, convexity, bounds\r\n\r\n**Testing Approach:**\r\n- Manual testing with visual verification\r\n- Assertion checks (`GUARANTEE_OR_DIE`) for correctness validation\r\n- Performance profiling with different object counts\r\n\r\n### Integration Testing\r\n\r\n**Key Flows to Test:**\r\n- Scene generation → Spatial structure build → Raycast queries\r\n- Object manipulation → Spatial structure rebuild → Raycast queries\r\n- Optimization mode cycling → Performance measurement → UI display\r\n\r\n**Testing Approach:**\r\n- Interactive testing with keyboard controls\r\n- Visual verification of debug modes (F1, F4)\r\n- Performance comparison across optimization modes\r\n\r\n### End-to-End Testing\r\n\r\n**User Scenarios to Test:**\r\n1. **Scenario: Generate Scene and Test Raycasts**\r\n   - Start application → Press 'T' → Verify timing displayed\r\n   - Press 'Y'/'U' to change object count → Press 'T' → Verify performance scales\r\n\r\n2. **Scenario: Manipulate Objects**\r\n   - Hover over object → Verify highlight\r\n   - Drag object → Verify smooth movement, sticky focus\r\n   - Rotate object (W/R) → Verify rotation around cursor\r\n   - Scale object (K/L) → Verify scaling around cursor\r\n\r\n3. **Scenario: Toggle Rendering Modes**\r\n   - Press F2 → Verify Mode A (translucent fill + opaque edges)\r\n   - Press F2 → Verify Mode B (composite concave appearance)\r\n\r\n4. **Scenario: Debug Visualization**\r\n   - Reduce to 1 object → Verify convex hull planes shown\r\n   - Press F1 → Verify bounding discs shown\r\n   - Press F4 → Verify spatial structure shown\r\n   - Press F9 → Cycle optimization modes → Verify performance changes\r\n\r\n5. **Scenario: Performance Analysis**\r\n   - Test with 16, 256, 1024 objects\r\n   - Record raycasts/ms for each optimization mode\r\n   - Document findings in README.txt\r\n\r\n## Performance Considerations\r\n\r\n### Optimization Strategies\r\n\r\n1. **Broad-Phase Culling**\r\n   - Bounding disc rejection (fast, conservative)\r\n   - Bounding AABB rejection (slightly slower, tighter)\r\n\r\n2. **Spatial Partitioning**\r\n   - QuadTree: Fixed depth (4 levels), uniform subdivision\r\n   - BVH: Adaptive depth (log2(N) - 3), binary splits\r\n\r\n3. **Memory Layout**\r\n   - Convex shapes stored as pointers (avoid copying)\r\n   - Spatial structures store pointers (no duplication)\r\n   - Vertex lists generated on-demand for rendering\r\n\r\n4. **Algorithmic Complexity**\r\n   - Brute force: O(N × M) where N=objects, M=rays\r\n   - Disc rejection: O(N × M) but with early exit\r\n   - Spatial structures: O(log(N) × M) average case\r\n\r\n### Expected Performance Targets\r\n\r\n- **60 FPS** with 256 objects (normal operation)\r\n- **< 100ms** for 1024 rays × 1024 objects (Release build, with optimization)\r\n- **< 10ms** for spatial structure rebuild (1024 objects)\r\n\r\n## Implementation Notes\r\n\r\n### Build Configurations\r\n\r\n- **Debug**: Full debugging symbols, no optimization, assertions enabled\r\n- **Release**: Full optimization, no debugging symbols, assertions disabled\r\n- **DebugInline**: Debug symbols + inline optimization\r\n- **FastBreak**: Release optimization + debugging symbols\r\n\r\n### Submission Requirements\r\n\r\n- Perforce changelist: \"SD4-A1: COMPLETE\"\r\n- Release-built .EXE included\r\n- README.txt with performance analysis\r\n- Voice-narrated video demonstration\r\n- Highlighted assignment document (cyan=complete, red=omitted, yellow=partial)\r\n\r\n## Future Enhancements (Out of Scope)\r\n\r\n- ❌ Concave polygon support\r\n- ❌ Moving/animated objects\r\n- ❌ Physics simulation\r\n- ❌ Save/load scene functionality\r\n- ❌ Multiple visible raycasts\r\n- ❌ Audio feedback\r\n- ❌ Network multiplayer\r\n- ❌ Advanced rendering effects\r\n",
  "fileStats": {
    "size": 25202,
    "lines": 715,
    "lastModified": "2026-02-01T19:17:56.610Z"
  },
  "comments": []
}