{
  "id": "snapshot_1769972207947_kcqb64n2t",
  "approvalId": "approval_1769968861080_5q5wwyx88",
  "approvalTitle": "Requirements Document - Convex Scene Editor",
  "version": 2,
  "timestamp": "2026-02-01T18:56:47.947Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document: Convex Scene Editor\r\n\r\n## Introduction\r\n\r\nThe Convex Scene Editor is a 2D interactive application for visualizing and testing raycast algorithms against convex polygons. This educational tool demonstrates spatial optimization techniques (BVH, QuadTree) and provides real-time performance metrics for comparing different raycast optimization strategies. The application allows users to manipulate convex shapes, perform batch raycasting tests, and analyze performance characteristics across different object counts and optimization modes.\r\n\r\n## Alignment with Product Vision\r\n\r\nThis project serves as a practical implementation of computational geometry concepts, specifically:\r\n- Convex hull representation and manipulation\r\n- Ray-convex intersection algorithms\r\n- Spatial partitioning optimization techniques (BVH, QuadTree)\r\n- Performance analysis and algorithmic complexity observation\r\n\r\nThe tool provides hands-on experience with game engine architecture patterns and real-time rendering systems.\r\n\r\n## Requirements\r\n\r\n### REQ-1: Random Convex Scene Generation\r\n\r\n**User Story:** As a user, I want to see a scene with randomly generated convex polygons, so that I can test raycast algorithms against varied geometric configurations.\r\n\r\n**Points:** 10\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the application starts THEN the system SHALL display N=8 random static convex polygons\r\n2. WHEN a convex polygon is generated THEN it SHALL have between 3-8 vertices\r\n3. WHEN vertices are generated THEN they SHALL form a valid convex polygon (CCW winding order)\r\n4. WHEN polygons are displayed THEN they SHALL fit within the world bounds (200x100 units)\r\n5. WHEN polygons are generated THEN each SHALL have a unique random position, size, and rotation\r\n\r\n### REQ-2: Dual Rendering Modes\r\n\r\n**User Story:** As a user, I want to toggle between two different rendering modes, so that I can visualize how overlapping convex shapes create composite concave appearances.\r\n\r\n**Points:** 5\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the user presses F2 THEN the system SHALL toggle between Mode A and Mode B\r\n2. WHEN Mode A is active THEN objects SHALL be drawn with translucent fill (alpha=128) and thick opaque edges\r\n3. WHEN Mode B is active (default) THEN all object edges SHALL be drawn first (thick, opaque, dark) followed by all object fills (opaque, light)\r\n4. WHEN Mode B is active AND objects overlap THEN the system SHALL create the appearance of composite concave shapes\r\n5. WHEN rendering mode changes THEN the system SHALL update the display immediately\r\n\r\n### REQ-3: Visible Raycast Visualization\r\n\r\n**User Story:** As a user, I want to see a single raycast with its impact point and surface normal, so that I can understand how ray-convex intersection works visually.\r\n\r\n**Points:** 12\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the scene is rendered THEN the system SHALL display one visible raycast\r\n2. WHEN the raycast hits a convex object THEN the system SHALL draw:\r\n   - The ray line from start to impact point (green)\r\n   - The full ray line from start to end (black arrow)\r\n   - The surface normal at impact point as a 2D arrow (red, length=3 units)\r\n3. WHEN the raycast misses all objects THEN the system SHALL draw only the full ray line (black arrow)\r\n4. WHEN the user holds 'S' or LMB THEN the raycast start position SHALL follow the mouse cursor\r\n5. WHEN the user holds 'E' or RMB THEN the raycast end position SHALL follow the mouse cursor\r\n\r\n### REQ-4: Batch Raycast Performance Testing\r\n\r\n**User Story:** As a user, I want to fire M random raycasts and see the elapsed time, so that I can measure and compare raycast performance across different optimization strategies.\r\n\r\n**Points:** 15\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the user presses 'T' THEN the system SHALL fire M=1024 invisible random raycasts\r\n2. WHEN batch raycasting starts THEN the system SHALL record the start time with high precision\r\n3. WHEN all raycasts complete THEN the system SHALL record the end time and calculate elapsed milliseconds\r\n4. WHEN raycasts are generated THEN each SHALL have random start and end positions within world bounds\r\n5. WHEN batch raycasting completes THEN the system SHALL display the elapsed time on screen\r\n6. WHEN the user presses 'Y' THEN the system SHALL halve the raycast count (minimum 1)\r\n7. WHEN the user presses 'U' THEN the system SHALL double the raycast count (maximum 134,217,728)\r\n\r\n### REQ-5: Debug Visualization for Single Object\r\n\r\n**User Story:** As a developer, I want to see convex hull planes and ray test points when only one object exists, so that I can debug and understand the ray-convex intersection algorithm.\r\n\r\n**Points:** 6\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN only 1 convex object exists THEN the system SHALL draw all convex hull planes as infinite lines\r\n2. WHEN a plane is being entered (ray approaching from outside) THEN it SHALL be drawn in magenta with the intercept point marked\r\n3. WHEN a plane is rejected (ray parallel or moving away) THEN it SHALL be drawn in red\r\n4. WHEN a plane is behind the ray THEN it SHALL be drawn in green\r\n5. WHEN multiple objects exist THEN the system SHALL NOT draw debug visualization\r\n\r\n### REQ-6: Mouse Hover Detection\r\n\r\n**User Story:** As a user, I want to see which convex object my mouse is hovering over, so that I can identify and interact with specific shapes.\r\n\r\n**Points:** 5\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the mouse cursor is inside a convex object THEN that object SHALL be highlighted\r\n2. WHEN the mouse cursor is inside multiple overlapping objects THEN only the topmost (last drawn) object SHALL be highlighted\r\n3. WHEN a highlighted object is rendered THEN it SHALL use a distinct color (blue fill, black edges)\r\n4. WHEN the mouse moves outside all objects THEN no object SHALL be highlighted\r\n\r\n### REQ-7: Sticky Hover Behavior\r\n\r\n**User Story:** As a user, I want the highlighted object to remain locked while I'm hovering over it, so that I can reliably interact with the same object even when moving the mouse quickly.\r\n\r\n**Points:** 4\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN an object is highlighted THEN the highlight SHALL NOT change to another object\r\n2. WHEN the mouse moves outside the current highlighted object THEN the system SHALL clear the highlight\r\n3. WHEN the mouse re-enters the scene THEN the system SHALL detect and highlight the appropriate object\r\n4. WHEN dragging an object THEN the highlight SHALL remain locked to that object\r\n\r\n### REQ-8: Spatial Partitioning Optimization\r\n\r\n**User Story:** As a developer, I want to implement spatial partitioning schemes, so that I can optimize raycast performance for scenes with many objects.\r\n\r\n**Points:** 12\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the scene is initialized THEN the system SHALL build at least one spatial partitioning structure (BVH or QuadTree)\r\n2. WHEN objects are added/removed/transformed THEN the system SHALL rebuild the spatial structure\r\n3. WHEN a raycast is performed with spatial optimization THEN the system SHALL query the structure to get candidate objects\r\n4. WHEN the user presses F4 THEN the system SHALL toggle debug visualization of the spatial structure\r\n5. WHEN spatial structure is visualized THEN bounding volumes SHALL be drawn as semi-transparent boxes/regions\r\n6. WHEN the user presses F9 THEN the system SHALL cycle through optimization modes:\r\n   - None (brute force)\r\n   - Disc rejection only\r\n   - AABB rejection only\r\n   - Spatial structure (QuadTree)\r\n   - Spatial structure (BVH)\r\n\r\n### REQ-9: Object Manipulation Controls\r\n\r\n**User Story:** As a user, I want to rotate, scale, and drag convex objects, so that I can interactively modify the scene configuration.\r\n\r\n**Points:** 12\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the user holds 'W' AND an object is highlighted THEN the object SHALL rotate clockwise around the mouse cursor at 90°/second\r\n2. WHEN the user holds 'R' AND an object is highlighted THEN the object SHALL rotate counter-clockwise around the mouse cursor at 90°/second\r\n3. WHEN the user holds 'L' AND an object is highlighted THEN the object SHALL scale up (inflate) around the mouse cursor at 1.0/second\r\n4. WHEN the user holds 'K' AND an object is highlighted THEN the object SHALL scale down (deflate) around the mouse cursor at 1.0/second\r\n5. WHEN the user clicks LMB on a highlighted object THEN dragging SHALL begin\r\n6. WHEN dragging is active THEN the object SHALL move with the mouse while preserving the initial grab offset\r\n7. WHEN dragging is active THEN the object SHALL NOT lose focus even when passing over other objects\r\n8. WHEN the user releases LMB THEN dragging SHALL end\r\n9. WHEN the user clicks LMB with no highlighted object THEN nothing SHALL happen\r\n\r\n### REQ-10: Scene Management Controls\r\n\r\n**User Story:** As a user, I want to add/remove objects and regenerate the scene, so that I can test different scene configurations.\r\n\r\n**Points:** 12\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the user presses 'N' THEN the system SHALL halve the number of objects (minimum 1)\r\n2. WHEN the user presses 'M' THEN the system SHALL double the number of objects (maximum 2048)\r\n3. WHEN objects are added THEN they SHALL be randomly generated using the same algorithm\r\n4. WHEN objects are removed THEN they SHALL be removed from the end of the array\r\n5. WHEN the user presses F8 THEN the system SHALL regenerate all shapes with new random configurations\r\n6. WHEN F8 is pressed THEN the current object count SHALL be preserved\r\n7. WHEN the user presses F1 THEN the system SHALL toggle debug draw of bounding discs for all objects\r\n\r\n### REQ-11: On-Screen Metrics Display\r\n\r\n**User Story:** As a user, I want to see real-time performance metrics on screen, so that I can analyze raycast performance characteristics.\r\n\r\n**Points:** 6\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the application is running THEN the system SHALL display:\r\n   - Current number of convex objects\r\n   - Number of invisible raycasts (M value for next 'T' press)\r\n   - Current spatial partitioning scheme name (or \"None\")\r\n   - Current FPS (frames per second)\r\n   - Last batch raycast elapsed time in milliseconds\r\n2. WHEN metrics are displayed THEN they SHALL be clearly readable (font size ≥17px)\r\n3. WHEN metrics are displayed THEN they SHALL be positioned at the top of the screen\r\n4. WHEN metrics update THEN the display SHALL refresh immediately\r\n\r\n### REQ-12: Performance Analysis Documentation\r\n\r\n**User Story:** As a developer, I want to document performance findings in a README, so that I can analyze and communicate the effectiveness of different optimization strategies.\r\n\r\n**Points:** 10\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN the project is submitted THEN a README.txt file SHALL exist\r\n2. WHEN the README is read THEN it SHALL include:\r\n   - Raycasts/ms performance for 16, 256, and 1024 objects\r\n   - Performance comparison with ray-disc rejection enabled vs disabled\r\n   - Performance comparison with spatial partitioning enabled vs disabled\r\n   - Performance comparison across build configurations (Debug, Release, DebugInline, FastBreak)\r\n   - Observed algorithmic complexity trends (O(N), O(N²), etc.)\r\n   - Spatial structure specific metrics (e.g., tree depth, node count)\r\n   - Any other interesting observations\r\n3. WHEN measurements are taken THEN they SHALL be from Release builds (except cross-build comparisons)\r\n4. WHEN the README is written THEN it SHALL be clear and succinct (not academic-formal)\r\n\r\n## Non-Functional Requirements\r\n\r\n### Code Architecture and Modularity\r\n\r\n- **Single Responsibility Principle**: Each class should have a single, well-defined purpose\r\n  - `Convex2` class handles convex shape representation and operations\r\n  - `AABB2Tree` class handles BVH spatial partitioning\r\n  - `SymmetricQuadTree` class handles quad tree spatial partitioning\r\n  - `Game` class orchestrates scene management and user interaction\r\n- **Modular Design**: Components should be isolated and reusable\r\n  - Convex shape generation should be a separate function\r\n  - Raycast algorithms should be encapsulated in the `Convex2` class\r\n  - Spatial structures should implement a common interface\r\n- **Dependency Management**: Minimize interdependencies between modules\r\n  - Spatial structures should only depend on `Convex2` pointers\r\n  - Rendering should be separated from game logic\r\n- **Clear Interfaces**: Define clean contracts between components\r\n  - `Convex2::RayCastVsConvex2D()` provides a consistent raycast interface\r\n  - Spatial structures provide `BuildTree()` and `SolveRayResult()` methods\r\n\r\n### Performance\r\n\r\n- **Raycast Performance**: The system SHALL support at least 1024 raycasts against 1024 objects in under 100ms (Release build)\r\n- **Frame Rate**: The system SHALL maintain at least 60 FPS during normal operation\r\n- **Spatial Structure Build Time**: Tree rebuilding SHALL complete in under 10ms for 1024 objects\r\n- **Memory Efficiency**: Spatial structures SHALL use O(N) memory where N is the number of objects\r\n\r\n### Reliability\r\n\r\n- **Deterministic Random Generation**: Using the same seed SHALL produce identical scenes\r\n- **Numerical Stability**: Raycast algorithms SHALL handle edge cases (parallel rays, grazing hits, etc.)\r\n- **Bounds Checking**: All objects SHALL remain within world bounds during generation and manipulation\r\n\r\n### Usability\r\n\r\n- **Visual Clarity**: All UI text SHALL be clearly readable with sufficient contrast\r\n- **Control Documentation**: All keyboard/mouse controls SHALL be displayed on-screen\r\n- **Immediate Feedback**: All user interactions SHALL provide immediate visual feedback\r\n- **Intuitive Controls**: Object manipulation SHALL feel natural and responsive\r\n\r\n### Testability\r\n\r\n- **Validation**: Batch raycast results SHALL be validated for correctness across optimization modes\r\n- **Reproducibility**: Performance measurements SHALL be reproducible with the same scene configuration\r\n- **Debug Visualization**: Debug modes SHALL provide sufficient information for algorithm verification\r\n\r\n## Technical Constraints\r\n\r\n- **Language**: C++ (C++17 or later)\r\n- **Engine**: Custom \"SD\" game engine (Guildhall student engine)\r\n- **Platform**: Windows (Visual Studio)\r\n- **Build Configurations**: Debug, Release, DebugInline, FastBreak\r\n- **World Dimensions**: 200 units (width) × 100 units (height)\r\n- **UI Dimensions**: 1600 pixels (width) × 800 pixels (height)\r\n\r\n## Success Criteria\r\n\r\nThe Convex Scene Editor is considered complete when:\r\n\r\n1. ✅ All 12 functional requirements are implemented and tested\r\n2. ✅ The application runs at 60+ FPS with 256 objects\r\n3. ✅ Batch raycasting completes in reasonable time (< 100ms for 1024 rays × 1024 objects in Release)\r\n4. ✅ All keyboard/mouse controls work as specified\r\n5. ✅ Performance metrics are accurately displayed on-screen\r\n6. ✅ README.txt contains comprehensive performance analysis\r\n7. ✅ Debug visualizations correctly display spatial structures and ray test points\r\n8. ✅ The application is stable and does not crash during normal operation\r\n\r\n## Out of Scope\r\n\r\nThe following features are explicitly NOT required for this assignment:\r\n\r\n- ❌ Concave polygon support\r\n- ❌ Moving/animated objects\r\n- ❌ Physics simulation (collision response, gravity, etc.)\r\n- ❌ Save/load scene functionality (bonus feature in reference implementation)\r\n- ❌ Multiple raycast visualization (only one visible ray required)\r\n- ❌ Audio feedback\r\n- ❌ Network multiplayer\r\n- ❌ Advanced rendering effects (shaders, lighting, shadows)\r\n",
  "fileStats": {
    "size": 15541,
    "lines": 292,
    "lastModified": "2026-02-01T18:06:56.830Z"
  },
  "comments": []
}